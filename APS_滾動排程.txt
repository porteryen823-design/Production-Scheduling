假如 SCHEDULE_START = datetime(2026, 1, 18, 13, 0, 0) 這是開始排程時間...已經排出一個版本..V1
然後 假如時間到 SCHEDULE_START = datetime(2026, 1, 18, 15, 0, 0),  你已經剛排好的一個排程. 有的作業站作完了.  有的正在做, 後又1批貨進來
這時你要做動態排程 原來已經投入做完的 跟正在做的 不能變更, 你要排出 V2版..   
之後照這邏輯 你就先做一個 每小時固定排新版的功能....
你可以依照上面批號 建立新進的lot...
你可以先把作業站都設為相同. 每小時進來的批數 用亂數 1~3批 這樣進去排程
原來程式你簡化初始時有 LOT_A001, LOT_B001, LOT_C001


動態排程, 你可能要把 一些資料用檔案處理 會比較好做!


若某個作業站上料後當機,目前排程不影響(模擬時不考慮,實務時會一直在同一個作業站 沒checkout,後續再討論如何處理)


- 滾動排程
	例如：
	- 16:00 → 求解 16:00–20:00 的任務
	- 17:00 → 更新狀態，再求解 17:00–21:00
	- 以此類推。
- 事件觸發 vs 定時觸發
	- 定時觸發：每隔 1 小時自動重新排程。
	- 事件觸發：當有新任務到來或資源狀態改變時立即重新排程。
	




# =====================================================
# 動態排程系統架構
# =====================================================

"""
┌─────────────────────────────────────────────────┐
│          Dynamic Scheduling System              │
├─────────────────────────────────────────────────┤
│                                                 │
│  ┌──────────────┐      ┌──────────────┐         │
│  │ Data Capture │ ───> │  Scheduler   │         │
│  │   Module     │      │    Engine    │         │
│  └──────────────┘      └──────────────┘         │
│         │                      │                │
│         ▼                      ▼                │
│  ┌──────────────┐      ┌──────────────┐         │
│  │   Database   │      │  Dispatcher  │         │
│  │   (State)    │      │   Module     │         │
│  └──────────────┘      └──────────────┘         │
│                                                 │
└─────────────────────────────────────────────────┘
"""

